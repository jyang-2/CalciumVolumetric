"""
Code for aggregating trial-level RDMs into a single RDM.

Steps:
-----
1. Load FlatFlyAcquisitions from manifest file
2. Load RDMs from each acquisition
3. Define a stimulus ordering for combining the RDMs
4. Order the RDMs according to the stimulus ordering
5. Aggregate the RDMs across acquisitions
6. Save the aggregated RDMs to a file
7. Plot the aggregated RDMs
8. Save the plots to a PDF file
"""

from typing import List

import pandas as pd
import pydantic
import xarray as xr

import natmixconfig
import ryeutils
from pydantic_models import FlatFlyAcquisitions


# Load RDMs from each acquisition, that were generated by scripts/step05c_compute_trial_rdms.py.
# Note that the RDMs are xarray Datasets, not DataArrays.
# The RDM files are saved in the folder named RDM_trials, in the suite2p output folder.
# The RDMs are saved in netcdf files named \
# xrds_suite2p_respvec__trialRDM__{respvec}__{metric}.h5, \
# where {respvec} is the name of the response vector type ('mean_peak' or 'max_peak'), \
# and {metric} is the metric used to compute the RDM ('cosine' or 'correlation').
# The RDM netcdf files are located in the folder named RDM_trials, in the suite2p output folder.


class ConcatenatedTrialRDMs(pydantic.BaseModel):
    """A model for concatenated trial RDMs."""


class PanelMovies(pydantic.BaseModel):
    """A class for specifying movie types for different odor panels.

    For more easily filtering/grouping FlatFlyAcquisitions.

    An odor panel is a grouping of odor stimuli that are presented together.

    The panel types in the natural_mixtures project include the following:
    - 'kiwi'
    - 'control'

    Attributes:
        prj (str): the project name (either 'natural_mixtures', 'odor_space_collab',
                   or 'odor_unpredictability)
        panel (str): name of the odor panel
        movies (List[str]): list of movie names
    """
    # Class attributes
    _allowed_projects = ['natural_mixtures',
                         'odor_space_collab',
                         'odor_unpredictability']
    _allowed_panels_by_project = {
        'natural_mixtures': ['kiwi', 'control'],
        'odor_space_collab': ['validation', 'megamat', 'odorspace'],
        'odor_unpredictability': ['cyanide']
    }
    _allowed_movie_types_by_panel = {
        'kiwi': ['kiwi',
                 'kiwi_components_again',
                 'kiwi_components_again_with_partial',
                 'kiwi_components_again_with_partial_and_probes'],
        'control': ['control1',
                    'control1_components_again_with_partial_and_probes'],
        'validation': ['validation0', 'validation1'],
        'megamat': ['megamat0'],
        'odorspace': ['odorspace0', 'odorspace1'],
        'cyanide': ['cyanide']
    }
    prj: str
    panel: str
    movies: List[str]

    class Config:
        validate_assignment = True

    # if movies is None, then set movies to the default list of movies for the panel
    @pydantic.root_validator(pre=True, allow_reuse=True)
    def set_movies(cls, values):
        if values.get('movies') is None:
            values['movies'] = cls._allowed_movie_types_by_panel[values['panel']]
        return values


# %%

def load_rdms_by_flacq(flat_acq, respvec, metric):
    """Load RDMs from a FlatFlyAcquisition.

    Args:
        flat_acq (FlatFlyAcquisition): the FlatFlyAcquisition to load RDMs from
        respvec (str): the response vector type ('mean_peak' or 'max_peak')
        metric (str): the metric used to compute the RDM ('cosine' or 'correlation')

    Returns:
        rdm_ds (xarray.Dataset): the RDM Dataset
    """
    rdm_ds = xr.load_dataset(natmixconfig.NAS_PROC_DIR / flat_acq.stat_file().parent /
                             'RDM_trials' /
                             f'xrds_suite2p_respvec__trialRDM__{respvec}__{metric}.nc')
    return rdm_ds


def load_rdms_by_flacq_list(flat_acq_list, respvec, metric):
    """Load RDMs from a list of FlatFlyAcquisitions.

    Args:
        flat_acq_list (List[FlatFlyAcquisition]): the FlatFlyAcquisitions to load RDMs from
        respvec (str): the response vector type ('mean_peak' or 'max_peak')
        metric (str): the metric used to compute the RDM ('cosine' or 'correlation')

    Returns:
        rdm_ds_list (xarray.Dataset): the RDM Datasets
    """
    rdm_ds_list = []
    for flat_acq in flat_acq_list:
        rdm_ds = load_rdms_by_flacq(flat_acq, respvec, metric)
        rdm_ds_list.append(rdm_ds)
    # rdm_ds = xr.concat(rdm_ds_list, dim='trial')
    return rdm_ds_list


def filter_flacq_list(flacq_list, allowed_movie_types=None, has_s2p_output=True):
    """Filter a list of FlatFlyAcquisitions.

    Args:
        flacq_list (List[FlatFlyAcquisition]): the FlatFlyAcquisitions to filter
        allowed_movie_types (List[str]): the allowed movie types
        has_s2p_output (bool): whether the FlatFlyAcquisitions must have suite2p output
                               i.e. whether s2p_stat_file must be defined

    Returns:
        flacq_list (List[FlatFlyAcquisition]): the filtered FlatFlyAcquisitions
    """
    if allowed_movie_types is not None:
        flacq_list = list(filter(lambda x: x.movie_type in allowed_movie_types, flacq_list))
    if has_s2p_output:
        flacq_list = list(filter(lambda x: x.stat_file() is not None, flacq_list))
    return flacq_list


def combine_rdms(rdm_list):
    """Combine a list of RDMs into a single RDM.

    Args:
        rdm_list (List[xarray.Dataset]): the RDMs to combine

    Returns:
        rdm_ds (xarray.Dataset): the combined RDM
    """
    rdm_ds = xr.concat(rdm_list, dim='trial')
    return rdm_ds


def get_stim_multiindices(stim_list, index_stimuli_keys=['stim', 'run_occ', 'idx_in_run']):
    """"""
    stim_info = ryeutils.index_stimuli(stim_list)
    df_stim = pd.DataFrame(stim_info).loc[:, index_stimuli_keys]

    mi_row = pd.MultiIndex.from_frame(df_stim.add_prefix('row_'))
    mi_col = pd.MultiIndex.from_frame(df_stim.add_prefix('col_'))

    return mi_row, mi_col


def reassign_row_and_col_index(ds, row_index, col_index):
    """Reassign the row and column index of a Dataset.

    Args:
        ds (xarray.Dataset): the Dataset to reassign the index of
        row_index (pandas.MultiIndex): the new row index
        col_index (pandas.MultiIndex): the new column index

    Returns:
        ds (xarray.Dataset): the Dataset with the new row and column index
    """
    ds_mi = ds.assign_coords(trial_row=('trial_row', row_index))
    ds_mi = ds_mi.assign_coords(trial_col=('trial_col', col_index))
    return ds_mi


def prepare_dataset_for_concat(ds, index_stimuli_keys=['stim', 'run_occ', 'idx_in_run']):
    """Prepare a Dataset for concatenation.

    Args:
        ds (xarray.Dataset): the Dataset to prepare
        index_stimuli_keys (List[str]): the keys to use to index the stimuli

    Returns:
        ds (xarray.Dataset): the prepared Dataset
    """
    row, col = get_stim_multiindices(ds.stim, index_stimuli_keys=index_stimuli_keys)
    ds_prepared = reassign_row_and_col_index(ds, row, col)
    return ds_prepared


def prepare_ds_concat_to_save(ds_concat):
    return ds_concat.reset_index(['trial_row', 'trial_col'])


def make_ds_concat_multiindex(ds_concat, index_stimuli_keys=['stim', 'run_occ', 'idx_in_run']):
    row_coords = [f'row_{k}' for k in index_stimuli_keys]
    col_coords = [f'col_{k}' for k in index_stimuli_keys]
    return ds_concat.set_index(trial_row=row_coords,
                               trial_col=col_coords)


if __name__ == '__main__':

    # get list of allowed movies, depending on panel
    kiwi_panel = PanelMovies(prj='natural_mixtures', panel='kiwi')
    control_panel = PanelMovies(prj='natural_mixtures', panel='control')

    # filter the flat_acq_list to only include the movies in desired panels
    flat_acqs = pydantic.parse_file_as(List[FlatFlyAcquisitions], natmixconfig.MANIFEST_FILE)
    flat_acqs = filter_flacq_list(flat_acqs,
                                  allowed_movie_types=kiwi_panel.movies + control_panel.movies)

    # split flat_acqs by odor panel, using the flacq.panel() method
    flat_acqs_by_panel = {}
    for flacq in flat_acqs:
        panel = flacq.panel()
        if panel not in flat_acqs_by_panel:
            flat_acqs_by_panel[panel] = []
        flat_acqs_by_panel[panel].append(flacq)

    # load RDMs for each panel, using the load_rdms_by_flacq_list function
    rdms_by_panel = {}
    for panel, flacqs in flat_acqs_by_panel.items():
        rdms_by_panel[panel] = load_rdms_by_flacq_list(flacqs, 'max_peak', 'cosine')

    # prepare the RDMs for concatenation
    prepared_rdms_by_panel = {}
    for panel, rdms in rdms_by_panel.items():
        prepared_rdms_by_panel[panel] = [prepare_dataset_for_concat(rdm) for rdm in rdms]

    # concatenate rdms
    rdm_concat_by_panel = {k: xr.concat(v, 'flacq') for k, v in prepared_rdms_by_panel.items()}

    # save concatenated rdms
    for panel, rdm_concat in rdm_concat_by_panel.items():
        OUTPUT_DIR = natmixconfig.NAS_PRJ_DIR.joinpath('analysis_outputs', 'RDM_trials')
        rdm_concat.to_netcdf(OUTPUT_DIR.joinpath(f'rdm_concat_{panel}.nc'))





